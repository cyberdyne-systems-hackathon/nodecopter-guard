<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * { margin: 0; padding: 0; }
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #camImage {
            position: absolute;
                top: 0; right: 0;
            width: 400px;
            height: auto;

            opacity: 0.9;
        }

        #battery {
            position: absolute;
                top: 0; left: 0;

            font-family: monospace;
            font-size: 26px;
        }

        #droneStateData, #gamepadStateData {
            color: white;
            font-size: 10px;
            font-family: monospace;
            position: absolute;
                bottom: 0; right: 0;

            width: 300px; height: 200px;

            background: rgba(0,0,0,0.5);
        }

        #gamepadStateData { left: 0; }
    </style>
</head>

<body>
<!-- 1px transparent gif… -->
<img id="camImage" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" />
<div id="battery">Battery: <span id="batteryMeter">100</span>%</div>
<pre id="droneStateData"></pre>
<pre id="gamepadStateData"></pre>


<script src="js/three.js/build/three.js"></script>
<script src="js/three.js/examples/js/loaders/OBJLoader.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>
    var $ = document.getElementById.bind(document);

    var batteryMeterEl = $('batteryMeter'),
        droneStateEl = $('droneStateData'),
        gamepadStateEl = $('gamepadStateData'),
        imgEl = $('camImage'),
        containerEl;


    var navData = null, droneState = null,
        lastBatteryPercentage = 100,
        loggingPaused = false;

    var socket = io.connect('http://localhost:3001');

    // these events might fire really rapidly, so we won't do much in the handler…
    socket.on('navdata', function (data) {
        droneState = data.droneState;
        navData = data.demo;
    });

    socket.on('image', function(src) { imgEl.src = src; });

    // ---- three.js setup
    var camera, floor, droneObject, scene, renderer;

    init();
    animate();

    function init() {
        containerEl = document.createElement('div');
        document.body.appendChild(containerEl);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 8000);
        camera.position.z = 6000;
        camera.position.y = 1500;

        // scene
        scene = new THREE.Scene();

        initLighting(scene);
        initModels(scene);

        // main init
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        containerEl.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize, false);
    }

    function initLighting(scene) {
        var ambient = new THREE.AmbientLight(0x404030);
        scene.add(ambient);

        var directionalLight = new THREE.DirectionalLight(0xffeedd);
        directionalLight.position.set(0, 1000, 1000);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
    }

    function initModels(scene) {
        initFloorModel(scene);
        initDroneModel(scene);
    }

    function initFloorModel(scene) {
        var floorTileCanvas = document.createElement("canvas"),
            context = floorTileCanvas.getContext("2d");

        floorTileCanvas.width = floorTileCanvas.height = 512;
        context.fillStyle = "#aac";
        context.fillRect(0, 0, 512, 512);
        context.fillStyle = "#ccf";

        context.fillRect(0, 0, 256, 256);
        context.fillRect(256, 256, 256, 256);

        var floorTexture = new THREE.Texture(floorTileCanvas, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping),
            floorMaterial = new THREE.MeshLambertMaterial({ map:floorTexture });

        floorTexture.needsUpdate = true;
        floorTexture.repeat.set(5000, 5000);

        var geometry = new THREE.PlaneGeometry(100, 100);

        floor = new THREE.Mesh(geometry, floorMaterial);

        floor.rotation.x = -Math.PI / 2;
        floor.scale.set(10000, 10000, 10000);
        floor.position.y = 0;
        floor.receiveShadow = true;

        scene.add(floor);
    }

    function initDroneModel(scene) {
        var loader = new THREE.OBJLoader();
        loader.addEventListener('load', function (event) {
            droneObject = event.content;

            droneObject.position.y = 1000;
            droneObject.scale.set(0.01, 0.01, 0.01);

            droneObject.castShadow = true;
            droneObject.receiveShadow = true;

            console.log(droneObject);
            scene.add(droneObject);
        });

        loader.load('ardrone2.obj');
    }


    // update camera and viewport on resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        renderScene();
        updateStateDisplays();
    }

    var deg2Rad = (function() {
        var RAD_PER_DEG = Math.PI/180;

        return function(deg) { return deg * RAD_PER_DEG; }
    } ());

    function renderScene() {
        if(navData) {
            var xr = deg2Rad(navData.frontBackDegrees),
                yr = deg2Rad(navData.clockwiseDegrees),
                zr = deg2Rad(navData.leftRightDegrees);

            droneObject.rotation.set( xr, -yr, -zr);
        }

        camera.lookAt(scene.position);
        renderer.render(scene, camera);
    }

    function updateStateDisplays() {
        if(!navData) { return; }
        droneStateEl.innerHTML = JSON.stringify(navData, null, 2);

        if (navData.batteryPercentage !== lastBatteryPercentage) {
            lastBatteryPercentage = navData.batteryPercentage;
            batteryMeterEl.innerHTML = lastBatteryPercentage;
        }
    }




    // ---- keyboard controls – kinda broken
    var keymap = {
        87 : { ev: 'move', param: 'front' }, // 'W'
        83 : { ev: 'move', param: 'back' }, // 'S'
        65 : { ev: 'move', param: 'left' }, // 'A'
        68 : { ev: 'move', param: 'right' }, // 'D'
        38 : { ev: 'move', param: 'up' }, // up
        40 : { ev: 'move', param: 'down' }, // down
        37 : { ev: 'move', param: 'counterClockwise' }, // left
        39 : { ev: 'move', param: 'clockwise' }, // right
        32 : { ev: 'drone', param: 'takeoff' }, // space
        27 : { ev: 'drone', param: 'land' },  // esc
        49 : { ev: 'animate', param: 'flipAhead', duration: 15 }, // 1
        50 : { ev: 'animate', param: 'flipLeft', duration: 15 }, // 2
        51 : { ev: 'animate', param: 'yawShake', duration: 15 }, // 3
        52 : { ev: 'animate', param: 'doublePhiThetaMixed', duration: 15 }, // 4
        53 : { ev: 'animate', param: 'wave', duration: 15 } // 5
    };

    var speed = 0;
    document.addEventListener("keydown", function (ev) {
        if(!keymap[ev.keyCode]) {
            //console.error('unmapped keycode', ev.keycode);
            return;
        }

        ev.preventDefault();

        speed = speed >= 1 ? 1 : speed + 0.08 / (1 - speed);

        var evData = keymap[ev.keyCode];
        //console.log('event', evData);
        socket.emit(evData.ev, { action: evData.param, speed: speed, duration: evData.duration });
    }, false);

    document.addEventListener("keyup", function (ev) {
        speed = 0;
        socket.emit('droneObject', { action: 'stop' });
    }, false);


    // ---- gamepad integration
    var BTN = {
        // Face (main) buttons
        FACE_1: 0, FACE_2: 1, FACE_3: 2, FACE_4: 3,
        // Top/bottom shoulder buttons
        LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,
        LEFT_SHOULDER_BOTTOM: 6, RIGHT_SHOULDER_BOTTOM: 7,
        SELECT: 8, START: 9,
        // Analogue stick-buttons (if depressible)
        LEFT_ANALOGUE_STICK: 10,
        RIGHT_ANALOGUE_STICK: 11,
        // Directional (discrete) pad
        PAD_TOP: 12, PAD_BOTTOM: 13, PAD_LEFT: 14, PAD_RIGHT: 15
    };

    var AXES = {
        LEFT_ANALOGUE_HOR: 0, LEFT_ANALOGUE_VERT: 1,
        RIGHT_ANALOGUE_HOR: 2, RIGHT_ANALOGUE_VERT: 3
    };

    // might be incomplete…
    var FLY_STATES = { FLYING_OK : 1 },
        CTRL_STATES = {
            CTRL_DEFAULT: 0,
            CTRL_TRANS_TAKEOFF: 1,
            CTRL_HOVERING: 2,
            CTRL_FLYING: 3,
            CTRL_TRANS_LANDING: 4,
            CTRL_LANDED: 5
        };

    gamepadStateEl.innerHTML = 'not connected';

    // initialize
    var lastGamepadState = {
        horiz: 0, vert: 0,
        btnStart: 0, btnStop: 0,
        btnTurnCW: 0, btnTurnCCW: 0,
        btnUp: 0, btnDown: 0
    };

    (function __controlLoop() {
        requestAnimationFrame(__controlLoop);

        // will only work in newer versions of chrome, no polyfill needed here…
        var gamepad = navigator.webkitGetGamepads()[0];

        if(!gamepad) { return; }

        // this is for better readability only and might be inlined.
        // I suspect the js-engine will likely do it anyway.
        var gamepadState = {
            // toFixed(1) to prevent too many useless nav-packets
            horiz: gamepad.axes[AXES.LEFT_ANALOGUE_HOR].toFixed(1),
            vert: gamepad.axes[AXES.LEFT_ANALOGUE_VERT].toFixed(1),

            btnStart: (1==gamepad.buttons[BTN.START]),
            btnStop: (1==gamepad.buttons[BTN.SELECT]),
            btnTurnCW: (1==gamepad.buttons[BTN.RIGHT_SHOULDER]),
            btnTurnCCW: (1==gamepad.buttons[BTN.LEFT_SHOULDER]),
            btnDown: (1==gamepad.buttons[BTN.FACE_1]),
            btnUp: (1==gamepad.buttons[BTN.FACE_4]),

            btnFlipFwd: (1==gamepad.buttons[BTN.PAD_TOP]),
            btnFlipBwd: (1==gamepad.buttons[BTN.PAD_BOTTOM]),
            btnFlipLeft: (1==gamepad.buttons[BTN.PAD_LEFT]),
            btnFlipRight: (1==gamepad.buttons[BTN.PAD_RIGHT])
        }

        // ---- logging
        gamepadStateEl.innerHTML = JSON.stringify(gamepadState, null, 2);

        // ---- analogue-stick left/right
        var horiz=gamepadState.horiz;
        if(horiz != lastGamepadState.horiz) { // negative: left
            if(horiz<0) {
                socket.emit('move', { action: 'left', speed: -horiz });
            } else if(horiz>0) {
                socket.emit('move', { action: 'right', speed: horiz });
            } else { // == 0
                socket.emit('move', { action: 'left', speed: 0 });
                socket.emit('move', { action: 'right', speed: 0 });
            }
        }

        // ---- analogue-stick up/down
        var vert=gamepadState.vert;
        if(vert != lastGamepadState.vert) { // negative: up
            if(vert<0) {
                socket.emit('move', { action: 'front', speed: -vert });
            } else if(vert>0) {
                socket.emit('move', { action: 'back', speed: vert });
            } else { // == 0
                socket.emit('move', { action: 'front', speed: 0 });
                socket.emit('move', { action: 'back', speed: 0 });
            }
        }

        // ---- takeoff/land
        if(gamepadState.btnStart && !lastGamepadState.btnStart) {
            if(!droneState.flying) {
                socket.emit('drone', { action: 'takeoff' });
            } else {
                socket.emit('drone', { action: 'land' });
            }
        }

        // ---- stop-button
        if(gamepadState.btnStop && !lastGamepadState.btnStop) {
            socket.emit('drone', { action: 'stop' });
        }

        // ---- up/down/cw/ccw buttons (TODO: add accelleration for more fine-grained control)
        var evMap = {
            btnUp: { ev: 'move', action: 'up', mode: 'toggleSpeed' },
            btnDown: { ev: 'move', action: 'down', mode: 'toggleSpeed' },
            btnTurnCW: { ev: 'move', action: 'clockwise', mode: 'toggleSpeed' },
            btnTurnCCW: { ev: 'move', action: 'counterClockwise', mode: 'toggleSpeed' },

            btnFlipFwd: { ev: 'animate', action: 'flipAhead', mode: 'trigger' },
            btnFlipBwd: { ev: 'animate', action: 'flipBehind', mode: 'trigger' },
            btnFlipLeft: { ev: 'animate', action: 'flipLeft', mode: 'trigger' },
            btnFlipRight: { ev: 'animate', action: 'flipRight', mode: 'trigger' }
        };

        Object.keys(evMap).forEach(function(btnId) {
            var evData = evMap[btnId],
                curr = gamepadState[btnId],
                last = lastGamepadState[btnId];

            if('toggleSpeed' == evData.mode) {
                if(curr && !last) { // btnPress
                    socket.emit(evData.ev, { action: evData.action, speed: 1 });
                } else if(!curr && last) { // btnRelease
                    socket.emit(evData.ev, { action: evData.action, speed: 0 });
                }
            } else if('trigger' == evData.mode) {
                if(curr && !last) {
                    socket.emit(evData.ev, { action: evData.action, duration: 15 });
                }
            }
        });


        lastGamepadState = gamepadState;
    } ());

</script>
</body>
</html>