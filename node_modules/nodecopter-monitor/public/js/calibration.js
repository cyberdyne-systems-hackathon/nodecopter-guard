(function(window) {
    // ---- gamepad integration
    var BTN = {
        // Face (main) buttons
        FACE_1: 0, FACE_2: 1, FACE_3: 2, FACE_4: 3,
        // Top/bottom shoulder buttons
        LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,
        LEFT_SHOULDER_BOTTOM: 6, RIGHT_SHOULDER_BOTTOM: 7,
        SELECT: 8, START: 9,
        // Analogue stick-buttons (if depressible)
        LEFT_ANALOGUE_STICK: 10,
        RIGHT_ANALOGUE_STICK: 11,
        // Directional (discrete) pad
        PAD_TOP: 12, PAD_BOTTOM: 13, PAD_LEFT: 14, PAD_RIGHT: 15
    };

    var AXES = {
        LEFT_ANALOGUE_HOR: 0, LEFT_ANALOGUE_VERT: 1,
        RIGHT_ANALOGUE_HOR: 2, RIGHT_ANALOGUE_VERT: 3
    };

    function Gamepad() {

    }
    var __ = Gamepad.prototype;

    __.controlLoop = function() {
        requestAnimationFrame(__controlLoop);


        // will only work in newer versions of chrome, no polyfill needed hereâ€¦
        var gamepad = navigator.webkitGetGamepads()[0];

        if(!gamepad) { return; }

        // this is for better readability only and might be inlined.
        // I suspect the js-engine will likely do it anyway.
        var gamepadState = {
            // toFixed(1) to prevent too many useless nav-packets
            horiz: gamepad.axes[AXES.LEFT_ANALOGUE_HOR].toFixed(1),
            vert: gamepad.axes[AXES.LEFT_ANALOGUE_VERT].toFixed(1),

            btnStart: (1==gamepad.buttons[BTN.START]),
            btnStop: (1==gamepad.buttons[BTN.SELECT]),
            btnTurnCW: (1==gamepad.buttons[BTN.RIGHT_SHOULDER]),
            btnTurnCCW: (1==gamepad.buttons[BTN.LEFT_SHOULDER]),
            btnDown: (1==gamepad.buttons[BTN.FACE_1]),
            btnUp: (1==gamepad.buttons[BTN.FACE_4]),

            btnFlipFwd: (1==gamepad.buttons[BTN.PAD_TOP]),
            btnFlipBwd: (1==gamepad.buttons[BTN.PAD_BOTTOM]),
            btnFlipLeft: (1==gamepad.buttons[BTN.PAD_LEFT]),
            btnFlipRight: (1==gamepad.buttons[BTN.PAD_RIGHT])
        }
    };
} (this));